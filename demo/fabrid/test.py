#!/usr/bin/env python3

# Copyright 2024 ETH Zurich
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import logging
import os
import random
import re
from subprocess import CalledProcessError
import time
import yaml
import threading
import sys

from plumbum import local
from plumbum.path import LocalPath

from acceptance.common import base, scion
from acceptance.common.docker import _CalledProcessErrorWithOutput
from tools.topology.scion_addr import ISD_AS

logger = logging.getLogger(__name__)


class Test(base.TestTopogen):
    def _init_as_list(self):
        # load list of ASes (generated by topogen scripts)
        as_list = self.artifacts / "gen/as_list.yml"
        self.isd_ases = scion.ASList.load(as_list).all

        random.seed(os.path.getctime(as_list))
        self.server_isd_as, self.client_isd_as = random.choices(self.isd_ases, k=2)
        while self.server_isd_as == self.client_isd_as:
            self.server_isd_as, self.client_isd_as = random.choices(self.isd_ases, k=2)

    def _run(self):
        time.sleep(10)  # wait until CSes are all up and running

        self._init_as_list()

        # install demo binary in tester containers:
        fabrid_demo = local["realpath"](self.get_executable("fabrid-demo").executable).strip()
        for ia in {self.server_isd_as, self.client_isd_as}:
            self.dc("cp", fabrid_demo, "endhost_%s" % ia.file_fmt() + ":/bin/")

        server_ip = self._endhost_ip(self.server_isd_as)
        client_ip = self._endhost_ip(self.client_isd_as)
        server_addr_with_port = "%s,%s:31015" % (self.server_isd_as, server_ip)
        client_addr = "%s,%s" % (self.client_isd_as, client_ip)

        failure_detected = threading.Event()

        def start_server_task():
            rs = ""
            try:
                rs = self.dc.execute("endhost_%s" % self.server_isd_as.file_fmt(),
                                    "fabrid-demo", "--mode=server",
                                    "--local", server_addr_with_port, "--remote", client_addr)
            except _CalledProcessErrorWithOutput as e:
                rs = "STDOUT:\n%s\nSTDERR:%s\n" % (e.base.stdout, e.base.stderr)
            print("server output\n", rs)
        
        def start_client_task():
            rc = ""
            try:
                rc = self.dc.execute("endhost_%s" % self.client_isd_as.file_fmt(),
                                    "fabrid-demo", "--mode=client",
                                    "--remote", server_addr_with_port, "--local", client_addr)
                self.dc.execute("endhost_%s" % self.server_isd_as.file_fmt(),
                                    "pkill", "fabrid-demo")
            except Exception as e:
                print(f"Error in start_client_task: {e}")
                failure_detected.set()
            print("client output\n", rc)
        
        thread1 = threading.Thread(target=start_server_task)
        thread2 = threading.Thread(target=start_client_task)

        # Start the threads
        thread1.start()
        thread2.start()

        # Wait for both threads to finish
        thread1.join()
        thread2.join()

        if failure_detected.is_set():
            raise RuntimeError

    def _endhost_ip(self, isd_as: ISD_AS) -> str:
        """ Determine the IP used for the end host (client or server) in the given ISD-AS """
        # The address must be the daemon IP (as it makes requests to the control
        # service on behalf of the end host application).
        return self._container_ip("endhost_%s" % isd_as.file_fmt())

    def _container_ip(self, container: str) -> str:
        """ Determine the IP of the container """
        dc_config = yaml.safe_load(self.dc.compose_file.read())
        networks = dc_config["services"][container]["networks"]
        addresses = next(iter(networks.values()))
        return next(iter(addresses.values()))

    def _conf_dir(self, isd_as: ISD_AS) -> LocalPath:
        """ Returns the path of the configuration directory for the given ISD-AS """
        return self.artifacts / "gen" / ("AS" + isd_as.as_file_fmt())


if __name__ == '__main__':
    base.main(Test)
